using PT4;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml.Schema;

namespace PT4Tasks
{
    public class MyTask : PT
    {
        // При решении задач группы LinqBegin доступны следующие
        // дополнительные методы, определенные в задачнике:
        //
        //   GetEnumerableInt() - ввод числовой последовательности;
        //
        //   GetEnumerableString() - ввод строковой последовательности;
        //
        //   Put() (метод расширения) - вывод последовательности;
        //
        //   Show() и Show(cmt) (методы расширения) - отладочная печать
        //     последовательности, cmt - строковый комментарий;
        //
        //   Show(e => r) и Show(cmt, e => r) (методы расширения) -
        //     отладочная печать значений r, полученных из элементов e
        //     последовательности, cmt - строковый комментарий.


        /// <summary>
        /// EN: Uncomment lines for required task
        /// RU: Убрать комментарии для запуска нужной задачи
        /// </summary>
        public static void Solve()
        {
            #region First group: LinqBegin1-LinqBegin15
            //LinqBegin1°. Дана целочисленная последовательность, 
            //содержащая как положительные, так и отрицательные числа. 
            //Вывести ее первый положительный элемент и последний отрицательный элемент.

            //Task("LinqBegin1");
            //var a = GetEnumerableInt();
            //Put(a.First(e => e>0));
            //Put(a.Last(e => e < 0));

            //LinqBegin2°. Дана цифра D(однозначное целое число) и целочисленная последовательность A. 
            //Вывести первый положительный элемент последовательности A, оканчивающийся цифрой D. 
            //Если требуемых элементов в последовательности A нет, то вывести 0.

            //Task("LinqBegin2");
            //int d = GetInt();
            //var a = GetEnumerableInt();
            //Put(a.FirstOrDefault(e => e > 0 && e.ToString().EndsWith(d.ToString())));

            //LinqBegin3°. Дано целое число L(> 0) и строковая последовательность A. Вывести последнюю строку из A, 
            //начинающуюся с цифры и имеющую длину L.Если требуемых строк в последовательности A нет, то вывести строку «Not found».
            //Указание.Для обработки ситуации, связанной с отсутствием требуемых строк, использовать операцию ??.

            //Task("LinqBegin3");
            //int l = GetInt();
            //var a = GetEnumerableString();
            //Put(a.LastOrDefault(s => s.Length!=0 && s[0] >= '0' && s[0] <= '9' && s.Length == l) ?? "Not found");

            //LinqBegin4°. Дан символ С и строковая последовательность A.Если A содержит единственный элемент, 
            //оканчивающийся символом C, то вывести этот элемент; если требуемых строк в A нет, то вывести пустую строку; 
            //если требуемых строк больше одной, то вывести строку «Error».
            //Указание.Использовать try-блок для перехвата возможного исключения. 

            //Task("LinqBegin4");
            //char c = GetChar();
            //var a = GetEnumerableString();
            //try
            //{
            //    Put(a.SingleOrDefault(s => s.Length != 0 && s[s.Length - 1] == c) ?? "");
            //}
            //catch
            //{
            //    Put("Error");
            //}

            //LinqBegin5°. Дан символ С и строковая последовательность A.Найти количество элементов A, 
            //которые содержат более одного символа и при этом начинаются и оканчиваются символом C. 

            //Task("LinqBegin5");
            //char c = GetChar();
            //var a = GetEnumerableString();
            //Put(a.Count(s => s.Length > 1 && s[0] == c && s[s.Length - 1] == c));

            //LinqBegin6°. Дана строковая последовательность.Найти сумму длин всех строк, входящих в данную последовательность. 

            //Task("LinqBegin6");
            //Put(GetEnumerableString().Sum(s => s.Length));

            //LinqBegin7°. Дана целочисленная последовательность.Найти количество ее отрицательных элементов, а также их сумму. 
            //Если отрицательные элементы отсутствуют, то дважды вывести 0.

            //Task("LinqBegin7");
            //var i = GetEnumerableInt();
            //Put(i.Count(e => e < 0));
            //Put(i.Where(e => e< 0).Sum());

            //LinqBegin8°. Дана целочисленная последовательность.Найти количество ее положительных двузначных элементов, 
            //а также их среднее арифметическое(как вещественное число). 
            //Если требуемые элементы отсутствуют, то дважды вывести 0(первый раз как целое, второй — как вещественное).

            //Task("LinqBegin8");
            //var i = GetEnumerableInt();
            //Put(i.Count(e => e > 0 && e.ToString().Length == 2));
            //Put(i.Where(e => e > 0 && e.ToString().Length == 2).DefaultIfEmpty(0).Average());

            //LinqBegin9°. Дана целочисленная последовательность.
            //Вывести ее минимальный положительный элемент или число 0, если последовательность не содержит положительных элементов. 

            //Task("LinqBegin9");
            //Put(GetEnumerableInt().Where(e => e > 0).DefaultIfEmpty(0).Min());

            //LinqBegin10°. Дано целое число L(> 0) и строковая последовательность A. Строки последовательности A содержат только заглавные буквы латинского алфавита.
            //Среди всех строк из A, имеющих длину L, найти наибольшую(в смысле лексикографического порядка). 
            //Вывести эту строку или пустую строку, если последовательность не содержит строк длины L. 

            //Task("LinqBegin10");
            //int l = GetInt();
            //var a = GetEnumerableString();
            //Put(a.Where(s => s.Length==l).DefaultIfEmpty("").Max());

            //LinqBegin11°. Дана последовательность непустых строк. 
            //Используя метод Aggregate, получить строку, состоящую из начальных символов всех строк исходной последовательности.

            //Task("LinqBegin11");
            //Put(GetEnumerableString().Aggregate("", (str1,str2) => str1+str2[0]));

            //LinqBegin12°. Дана целочисленная последовательность.Используя метод Aggregate, 
            //найти произведение последних цифр всех элементов последовательности.
            //Чтобы избежать целочисленного переполнения, при вычислении произведения использовать вещественный числовой тип. 

            //Task("LinqBegin12");
            //Put(GetEnumerableInt().Select(x => Math.Abs(x%10)).Aggregate(1.0, (a, b) => a*b));

            //LinqBegin13°. Дано целое число N(> 0). Используя методы Range и Sum, найти сумму 1 + (1 / 2) + … +(1 / N)(как вещественное число).

            //Task("LinqBegin13");
            //int n = GetInt();
            //Put(Enumerable.Range(1,n).Sum(e => 1.0/e));

            //LinqBegin14°. Даны целые числа A и B(A<B). Используя методы Range и Average, найти среднее арифметическое квадратов всех 
            //целых чисел от A до B включительно: (A2 + (A + 1)2 + … +B2)/ (B − A + 1) (как вещественное число). 

            //Task("LinqBegin14");
            //int a = GetInt();
            //int b = GetInt();
            //Put(Enumerable.Range(a, b - a + 1).Average(x => x * x));

            //LinqBegin15°. Дано целое число N(0 ≤ N ≤ 15). Используя методы Range и Aggregate, найти факториал числа N: N! = 1·2·…·N при N ≥ 1; 0! = 1.
            //Чтобы избежать целочисленного переполнения, при вычислении факториала использовать вещественный числовой тип.

            //Task("LinqBegin15");
            //int n = GetInt();
            //Put(Enumerable.Range(0, n).Aggregate(1.0, (num1, num2) => num1 + num1 * num2));
            #endregion

            #region Second group: LinqBegin16-LinqBegin31
            //RU: В большинстве заданий из этого блока
            //первое число должно быть КОЛИЧЕСТВОМ элементов выходной последовательности, 
            //хотя в заданиях об этом не сказано
            //EN: The first number (in the most tasks from this block) must be the Number of elements in output

            //LinqBegin16°. Дана целочисленная последовательность.Извлечь из нее все положительные числа, сохранив их исходный порядок следования. 

            //Task("LinqBegin16");
            //var numbers = GetEnumerableInt().Where(e=>e>0);
            //Put(numbers.Count(), numbers.Select(e => e));

            //LinqBegin17°. Дана целочисленная последовательность.Извлечь из нее все нечетные числа, 
            //сохранив их исходный порядок следования и удалив все вхождения повторяющихся элементов, кроме первых.

            //Task("LinqBegin17");
            //var numbers = GetEnumerableInt().Where(e => e % 2 == 1).Distinct();
            //Put(numbers.Count(), numbers);

            //LinqBegin18°. Дана целочисленная последовательность.Извлечь из нее все четные отрицательные числа, поменяв порядок извлеченных чисел на обратный. 

            //Task("LinqBegin18");
            //var numbers = GetEnumerableInt().Where(e => e % 2 == 0 && e < 0).Reverse();
            //Put(numbers.Count(), numbers);

            //LinqBegin19°. Дана цифра D(целое однозначное число) и целочисленная последовательность A. 
            //Извлечь из A все различные положительные числа, оканчивающиеся цифрой D(в исходном порядке).
            //При наличии повторяющихся элементов удалять все их вхождения, кроме последних.
            //Указание.Последовательно применить методы Reverse, Distinct, Reverse

            //Task("LinqBegin19");
            //var d = GetInt();
            //var numbers = GetEnumerableInt().Where(e => e % 10 == d).Reverse().Distinct().Reverse();
            //Put(numbers.Count(), numbers);

            //LinqBegin20°. Дана целочисленная последовательность.Извлечь из нее все положительные двузначные числа, отсортировав их по возрастанию.

            //Task("LinqBegin20");
            //var numbers = GetEnumerableInt().Where(e => e >= 10 && e <= 99).OrderBy(e => e);
            //Put(numbers.Count(), numbers);

            //LinqBegin21°. Дана строковая последовательность.Строки последовательности содержат только заглавные буквы латинского алфавита. 
            //Отсортировать последовательность по возрастанию длин строк, а строки одинаковой длины — в лексикографическом порядке по убыванию.

            //Task("LinqBegin21");
            //var strings = GetEnumerableString().OrderBy(e => e.Length).ThenByDescending(e=>e);
            //Put(strings.Count(), strings);

            //LinqBegin22°. Дано целое число K(> 0) и строковая последовательность A. 
            //Строки последовательности содержат только цифры и заглавные буквы латинского алфавита. 
            //Извлечь из A все строки длины K, оканчивающиеся цифрой, отсортировав их в лексикографическом порядке по возрастанию. 

            //Task("LinqBegin22");
            //int k = GetInt();
            //var a = GetEnumerableString().Where(e => e.Length == k && e[e.Length - 1] >= '0' && e[e.Length - 1] <= '9').OrderBy(s => s);
            //Put(a.Count(), a);

            //LinqBegin23°. Дано целое число K(> 0) и целочисленная последовательность A. 
            //Начиная с элемента A с порядковым номером K, извлечь из A все нечетные двузначные числа, отсортировав их по убыванию.

            //Task("LinqBegin23");
            //int k = GetInt();
            //var a = GetEnumerableInt().Skip(k - 1).Where(e => Math.Abs(e / 10) >= 1 && Math.Abs(e / 10) <= 9 && Math.Abs(e % 2) == 1).OrderByDescending(n=>n);
            //Put(a.Count(), a);

            //LinqBegin24°. Дано целое число K(> 0) и строковая последовательность A. Из элементов A, предшествующих элементу с порядковым номером K, извлечь те строки, 
            //которые имеют нечетную длину и начинаются с заглавной латинской буквы, изменив порядок следования извлеченных строк на обратный.

            //Task("LinqBegin24");
            //int k = GetInt();
            //var a = GetEnumerableString().Take(k-1).Where(e => e.Length % 2 == 1 && e[0]>='A' && e[0]<='Z').Reverse();
            //Put(a.Count(), a);

            //LinqBegin25°. Даны целые числа K1 и K2 и целочисленная последовательность A; 1 ≤ K1 < K2 ≤ N, где N — размер последовательности A.
            //Найти сумму положительных элементов последовательности с порядковыми номерами от K1 до K2 включительно.

            //Task("LinqBegin25");
            //int k1 = GetInt();
            //int k2 = GetInt();
            //Put(GetEnumerableInt().Skip(k1-1).Take(k2-k1+1).Where(e => e > 0).Sum());

            //LinqBegin26°. Даны целые числа K1 и K2 и последовательность непустых строк A; 1 < K1 < K2 ≤ N, 
            //где N — размер последовательности A.Найти среднее арифметическое длин всех элементов последовательности, 
            //кроме элементов с порядковыми номерами от K1 до K2 включительно, и вывести его как вещественное число.

            //Task("LinqBegin26");
            //int k1 = GetInt();
            //int k2 = GetInt();
            //var a = GetEnumerableString();
            //Put(a.Take(k1-1).Union(a.Skip(k2).Take(a.Count()-k2)).Select(e=>e.Length).Average());

            //LinqBegin27°. Дано целое число D и целочисленная последовательность A. Начиная с первого элемента A, большего D, 
            //извлечь из A все нечетные положительные числа, поменяв порядок извлеченных чисел на обратный.

            //Task("LinqBegin27");
            //int d = GetInt();
            //var a = GetEnumerableInt().SkipWhile(e => e < d).Where(n => n % 2 == 1 && n > 0).Reverse();
            //Put(a.Count(), a);

            //LinqBegin28°. Дано целое число L(> 0) и последовательность непустых строк A.
            //Строки последовательности содержат только цифры и заглавные буквы латинского алфавита. 
            //Из элементов A, предшествующих первому элементу, длина которого превышает L, извлечь строки, оканчивающиеся буквой. 
            //Полученную последовательность отсортировать по убыванию длин строк, а строки одинаковой длины — в лексикографическом порядке по возрастанию.

            //Task("LinqBegin28");
            //int l = GetInt();
            //var a = GetEnumerableString().TakeWhile(e => e.Length <= l).Where(c => c[c.Length - 1] >= 'A' && c[c.Length - 1] <= 'Z').OrderByDescending(s => s.Length).ThenBy(s => s);
            //Put(a.Count(), a);

            //LinqBegin29°. Даны целые числа D и K(K > 0) и целочисленная последовательность A. 
            //Найти теоретико-множественное объединение двух фрагментов A: первый содержит все элементы до первого элемента, 
            //большего D(не включая его), а второй — все элементы, начиная с элемента с порядковым номером K. 
            //Полученную последовательность(не содержащую одинаковых элементов) отсортировать по убыванию.

            //Task("LinqBegin29");
            //int d = GetInt();
            //int k = GetInt();
            //var a = GetEnumerableInt();
            //var b = a.TakeWhile(e => e < d).Union(a.Skip(k - 1)).Distinct().OrderByDescending(e => e);
            //Put(b.Count(), b);

            //LinqBegin30°. Дано целое число K(> 0) и целочисленная последовательность A. 
            //Найти теоретико-множественную разность двух фрагментов A: первый содержит все четные числа, а второй — все числа с порядковыми номерами, большими K. 
            //В полученной последовательности(не содержащей одинаковых элементов) поменять порядок элементов на обратный.

            //Task("LinqBegin30");
            //int k = GetInt();
            //var a = GetEnumerableInt();
            //var b = a.Where(e => e % 2 == 0).Except(a.Skip(k)).Distinct().Reverse();
            //Put(b.Count(), b);

            //Дано целое число K(> 0) и последовательность непустых строк A.
            //Строки последовательности содержат только цифры и заглавные буквы латинского алфавита. 
            //Найти теоретико-множественное пересечение двух фрагментов A: первый содержит K начальных элементов, а второй — все элементы, 
            //расположенные после последнего элемента, оканчивающегося цифрой. 
            //Полученную последовательность(не содержащую одинаковых элементов) отсортировать по возрастанию длин строк, а строки одинаковой длины — в лексикографическом порядке по возрастанию.

            //Task("LinqBegin31");
            //int k = GetInt();
            //var a = GetEnumerableString();
            //var b = a.Take(k).Intersect(a.Reverse().
            //        TakeWhile(c=> !char.IsDigit(c[c.Length-1])).Reverse())
            //        .Distinct().OrderBy(s => s.Length).ThenBy(s=>s);
            //Put(b.Count(), b);

            #endregion

            #region Third group: LinqBegin32-LinqBegin43
            //LinqBegin32°. Дана последовательность непустых строк A.Получить последовательность символов, 
            //каждый элемент которой является начальным символом соответствующей строки из A. 
            //Порядок символов должен быть обратным по отношению к порядку элементов исходной последовательности. 

            //Task("LinqBegin32");
            //GetEnumerableString().Select(c => c[0]).Reverse().Put();

            //LinqBegin33°. Дана целочисленная последовательность.Обрабатывая только положительные числа, 
            //получить последовательность их последних цифр и удалить в полученной последовательности все вхождения одинаковых цифр, кроме первого. 
            //Порядок полученных цифр должен соответствовать порядку исходных чисел. 

            //Task("LinqBegin33");
            //GetEnumerableInt().Where(s => s >= 0).Select(n => n % 10).Distinct().Put();

            //LinqBegin34°. Дана последовательность положительных целых чисел.Обрабатывая только нечетные числа, 
            //получить последовательность их строковых представлений и отсортировать ее в лексикографическом порядке по возрастанию. 

            //Task("LinqBegin34");
            //GetEnumerableInt().Where(s => s % 2 == 1).Select(n => n.ToString()).OrderBy(c => c).Put();

            //LinqBegin35°. Дана целочисленная последовательность.Получить последовательность чисел, 
            //каждый элемент которой равен произведению соответствующего элемента исходной последовательности на его порядковый номер(1, 2, …).
            //В полученной последовательности удалить все элементы, не являющиеся двузначными, и поменять порядок оставшихся элементов на обратный.

            //Task("LinqBegin35");
            //int i = 1;
            //GetEnumerableInt().Select(n => n*(i++)).Where(n => Math.Abs(n) >= 10 && Math.Abs(n)<=99).Reverse().Put();

            //LinqBegin36°. Дана последовательность непустых строк. Получить последовательность символов, которая определяется следующим образом: 
            //если соответствующая строка исходной последовательности имеет нечетную длину, то в качестве символа берется первый символ этой строки; 
            //в противном случае берется последний символ строки.Отсортировать полученные символы по убыванию их кодов.

            //Task("LinqBegin36");
            //GetEnumerableString().Select(s => s.Length % 2 == 1 ? s[0] : s[s.Length - 1]).OrderByDescending(s=>s).Put();

            //LinqBegin37°. Дана строковая последовательность A. Строки последовательности содержат только заглавные буквы латинского алфавита. 
            //Получить новую последовательность строк, элементы которой определяются по соответствующим элементам A следующим образом: 
            //пустые строки в новую последовательность не включаются, а к непустым приписывается порядковый номер данной строки в исходной последовательности
            //(например, если пятый элемент A имеет вид «ABC», то в полученной последовательности он будет иметь вид «ABC5»).При нумерации должны учитываться и пустые строки последовательности A. 
            //Отсортировать полученную последовательность в лексикографическом порядке по возрастанию. 

            //Task("LinqBegin37");
            //GetEnumerableString().Select((s, i) => s.Length != 0 ? s + (i + 1).ToString():"").Where(s=> s.Length!=0).OrderBy(s=>s).Put();

            //LinqBegin38°. Дана целочисленная последовательность A. Получить новую последовательность чисел, элементы которой определяются по соответствующим элементам 
            //последовательности A следующим образом: если порядковый номер элемента A делится на 3(3, 6, …), 
            //то этот элемент в новую последовательность не включается; 
            //если остаток от деления порядкового номера на 3 равен 1(1, 4, …), то в новую последовательность добавляется удвоенное значение этого элемента; 
            //в противном случае(для элементов A с номерами 2, 5, …) элемент добавляется в новую последовательность без изменений.
            //В полученной последовательности сохранить исходный порядок следования элементов. 

            //Task("LinqBegin38");
            //GetEnumerableInt().Select((n, i) => (i + 1) % 3 == 1 ? 2 * n : (i+1) % 3 == 0 ? 3: n).Where(n=> n != 3).Put();

            //LinqBegin39°. Дана строковая последовательность A. Получить последовательность цифровых символов, входящих в строки последовательности A(символы могут повторяться). 
            //Порядок символов должен соответствовать порядку строк A и порядку следования символов в каждой строке. 
            //Указание.Использовать метод SelectMany с учетом того, что строка может интерпретироваться как последовательность символов. 

            //Task("LinqBegin39");
            //GetEnumerableString().SelectMany(n => n.Where(c => char.IsDigit(c))).Put();

            //LinqBegin40°. Дано число K(> 0) и строковая последовательность A. 
            //Получить последовательность символов, содержащую символы всех строк из A, имеющих длину, 
            //большую или равную K(символы могут повторяться). В полученной последовательности поменять порядок элементов на обратный. 

            //Task("LinqBegin40");
            //int k = GetInt();
            //GetEnumerableString().Where(s => s.Length>=k).SelectMany(n => n.ToString()).Reverse().Put();

            //LinqBegin41°. Дано целое число K(> 0) и строковая последовательность A. 
            //Каждый элемент последовательности представляет собой несколько слов из заглавных латинских букв, разделенных символами «.» (точка).
            //Получить последовательность строк, содержащую все слова длины K из элементов A в лексикографическом порядке по возрастанию(слова могут повторяться). 

            //Task("LinqBegin41");
            //int k = GetInt();
            //GetEnumerableString().SelectMany(n => n.Split('.')).Where(s => s.Length == k).OrderBy(s => s).Put();

            //LinqBegin42°. Дана последовательность непустых строк. Получить последовательность символов, которая определяется следующим образом: 
            //для строк с нечетными порядковыми номерами(1, 3, …) в последовательность символов включаются все прописные латинские буквы, содержащиеся в этих строках, 
            //а для строк с четными номерами(2, 4, …) — все их строчные латинские буквы.
            //В полученной последовательности символов сохранить их исходный порядок следования.

            //Task("LinqBegin42");
            //GetEnumerableString().SelectMany((s, i) => (i+1) % 2 == 1 ? 
            //                      s.Select(t => t).Where(k => char.IsUpper(k)) :
            //                      s.Select(t => t).Where(k => char.IsLower(k)))
            //                      .Put();

            //LinqBegin43°. Дано целое число K(> 0) и последовательность непустых строк A.
            //Получить последовательность символов, которая определяется следующим образом: для первых K элементов последовательности A в новую 
            //последовательность заносятся символы, стоящие на нечетных позициях данной строки(1, 3, …), 
            //а для остальных элементов A — символы на четных позициях(2, 4, …). 
            //В полученной последовательности поменять порядок элементов на обратный. 

            //Task("LinqBegin43");
            //int k = GetInt();
            //GetEnumerableString().SelectMany((s, i) => (i + 1)<=k ?
            //                     s.Where((c, j) => (j + 1)%2 == 1) :
            //                     s.Where((c, j) => (j + 1)%2 == 0))
            //                     .Reverse().Put();

            #endregion

            #region Fourth group: LinqBegin44-LinqBegin60
            //LinqBegin44°. Даны целые числа K1 и K2 и целочисленные последовательности A и B. Получить последовательность, 
            //содержащую все числа из A, большие K1, и все числа из B, меньшие K2. Отсортировать полученную последовательность по возрастанию.

            //Task("LinqBegin44");
            //int k1 = GetInt();
            //int k2 = GetInt();
            //GetEnumerableInt().Where(a => a > k1).Concat(GetEnumerableInt().Where(b => b < k2)).OrderBy(e => e).Put();

            //LinqBegin45°. Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
            //Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита. Получить последовательность, 
            //содержащую все строки из A длины L1 и все строки из B длины L2.Отсортировать полученную последовательность в лексикографическом порядке по убыванию. 

            //Task("LinqBegin45");
            //int l1 = GetInt();
            //int l2 = GetInt();
            //GetEnumerableString().Where(a => a.Length == l1)
            //                     .Concat(GetEnumerableString().Where(b => b.Length == l2))
            //                     .OrderByDescending(s => s).Put();

            //LinqBegin46°. Даны последовательности положительных целых чисел A и B; все числа в каждой последовательности различны. 
            //Найти последовательность всех пар чисел, удовлетворяющих следующим условиям: первый элемент пары принадлежит последовательности A, 
            //второй принадлежит B, и оба элемента оканчиваются одной и той же цифрой. Результирующая последовательность называется внутренним объединением 
            //последовательностей A и B по ключу, определяемому последними цифрами исходных чисел.Представить найденное объединение в виде 
            //последовательности строк, содержащих первый и второй элементы пары, разделенные дефисом, например, «49 - 129». 
            //Порядок следования пар должен определяться исходным порядком элементов последовательности A, а для равных первых элементов — порядком элементов последовательности B. 

            //Task("LinqBegin46");
            //var a = GetEnumerableInt();
            //var b = GetEnumerableInt();
            //a.Join(b, 
            //       x => x % 10, 
            //       y => y % 10, 
            //       (x, y) => string.Format("{0}-{1}", x, y))
            //       .Put();

            //LinqBegin47°. Даны последовательности положительных целых чисел A и B; все числа в каждой последовательности различны. 
            //Найти внутреннее объединение A и B(см.LinqBegin46), пары в котором должны удовлетворять следующему условию: последняя цифра первого 
            //элемента пары(из A) должна совпадать с первой цифрой второго элемента пары(из B). Представить найденное объединение в виде 
            //последовательности строк, содержащих первый и второй элементы пары, разделенные двоеточием, например, «49:921». 
            //Порядок следования пар должен определяться исходным порядком элементов последовательности A, 
            //а для равных первых элементов пар — лексикографическим порядком строковых представлений вторых элементов(по возрастанию). 

            //Task("LinqBegin47");
            //var a = GetEnumerableInt();
            //var b = GetEnumerableInt().OrderBy(e => e.ToString());
            //a.Join(b,
            //       x => x % 10,
            //       y => (int)char.GetNumericValue(y.ToString()[0]),
            //       (x, y) => string.Format("{0}:{1}", x, y))
            //       .Put();

            //LinqBegin48°. Даны строковые последовательности A и B; все строки в каждой последовательности различны, имеют ненулевую длину и 
            //содержат только цифры и заглавные буквы латинского алфавита.Найти внутреннее объединение A и B(см.LinqBegin46), каждая пара которого 
            //должна содержать строки одинаковой длины. Представить найденное объединение в виде последовательности строк, содержащих первый и 
            //второй элементы пары, разделенные двоеточием, например, «AB: CD». Порядок следования пар должен определяться лексикографическим 
            //порядком первых элементов пар(по возрастанию), а для равных первых элементов — лексикографическим порядком вторых элементов пар(по убыванию).

            //Task("LinqBegin48");
            //var a = GetEnumerableString().OrderBy(e => e);
            //var b = GetEnumerableString().OrderByDescending(e => e);
            //a.Join(b,
            //       x => x.Length-1,
            //       y => y.Length-1,
            //       (x,y) => string.Format("{0}:{1}",x,y))
            // .Put();

            //LinqBegin49°. Даны строковые последовательности A, B и С; все строки в каждой последовательности различны, 
            //имеют ненулевую длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Найти внутреннее объединение A, B и С(см.LinqBegin46), каждая тройка которого должна содержать строки, начинающиеся с одного и того же
            //символа. Представить найденное объединение в виде последовательности строк вида «EA = EB = EC», где EA, EB, EC — элементы из A, B, C 
            //соответственно. Для различных элементов EA сохраняется исходный порядок их следования, для равных элементов EA порядок троек 
            //определяется лексикографическим порядком элементов EB(по возрастанию), 
            //а для равных элементов EA и EB — лексикографическим порядком элементов EC(по убыванию). 

            //Task("LinqBegin49");
            //var a = GetEnumerableString();
            //var b = GetEnumerableString().OrderBy(e => e);
            //var c = GetEnumerableString().OrderByDescending(e => e);

            //a.Join(b
            //    .Join(c,
            //          x => x[0],
            //          y => y[0],
            //          (x, y) => string.Format("{0}={1}", x, y)),
            //          f => f[0],
            //          g => g[0],
            //          (f, g) => string.Format("{0}={1}", f, g)).Put();

            //LinqBegin50°. Даны строковые последовательности A и B; все строки в каждой последовательности различны и имеют ненулевую длину. 
            //Получить последовательность строк вида «E: N», где E обозначает один из элементов последовательности A, а N — количество элементов из B, 
            //начинающихся с того же символа, что и элемент E(например, «abc: 4»); количество N может быть равно 0.
            //Порядок элементов полученной последовательности должен определяться исходным порядком элементов последовательности A.
            //Указание.Использовать метод GroupJoin.

            //Task("LinqBegin50");
            //GetEnumerableString().GroupJoin(GetEnumerableString(),
            //            x => x[0],
            //            y => y[0],
            //            (x, y) => string.Format("{0}:{1}", x, y.Count()))
            // .Put();

            //LinqBegin51°. Даны последовательности положительных целых чисел A и B; все числа в последовательности A различны. 
            //Получить последовательность строк вида «S: E», где S обозначает сумму тех чисел из B, которые оканчиваются на ту же цифру, 
            //что и число E — один из элементов последовательности A(например, «74:23»); если для числа E не найдено ни одного подходящего 
            //числа из последовательности B, то в качестве S указать 0.Расположить элементы полученной последовательности по возрастанию значений найденных сумм, 
            //а при равных суммах — по убыванию значений элементов A.

            //Task("LinqBegin51");
            //GetEnumerableInt().GroupJoin(GetEnumerableInt(),
            //            x => x % 10,
            //            y => y % 10,
            //            (x, y) => new { x, y = y.Sum() })
            // .OrderBy(e => e.y)
            // .ThenByDescending(e => e.x)
            // .Select(e => e.y.ToString() + ':' + e.x.ToString()).Put();

            //LinqBegin52°. Даны строковые последовательности A и B; все строки в каждой последовательности различны, имеют ненулевую 
            //длину и содержат только цифры и заглавные буквы латинского алфавита.Получить последовательность всевозможных комбинаций 
            //вида «EA = EB», где EA — некоторый элемент из A, EB — некоторый элемент из B, причем оба элемента оканчиваются цифрой
            //(например, «AF3= D78»). Упорядочить полученную последовательность в лексикографическом порядке по возрастанию элементов EA,
            //а при одинаковых элементах EA — в лексикографическом порядке по убыванию элементов EB.
            //Указание.Для перебора комбинаций использовать методы SelectMany и Select. 

            //Task("LinqBegin52");
            //var a = GetEnumerableString().Where(e => char.IsDigit(e[e.Length-1])).OrderBy(e=>e);
            //var b = GetEnumerableString().Where(e => char.IsDigit(e[e.Length-1])).OrderByDescending(e => e);
            //a.SelectMany(e => b.Select(g => e + '='+g)).Put();

            //LinqBegin53°. Даны целочисленные последовательности A и B. Получить последовательность всех различных сумм, 
            //в которых первое слагаемое берется из A, а второе из B. Упорядочить полученную последовательность по возрастанию.

            //Task("LinqBegin53");
            //var a = GetEnumerableInt();
            //var b = GetEnumerableInt();
            //a.SelectMany(e => b.Select(f => e + f)).Distinct().OrderBy(e => e).Put();

            //LinqBegin54°. Даны строковые последовательности A и B; все строки в каждой последовательности различны, 
            //имеют ненулевую длину и содержат только цифры и заглавные буквы латинского алфавита.Найти последовательность всех пар строк,
            //удовлетворяющих следующим условиям: первый элемент пары принадлежит последовательности A, а второй либо является одним из 
            //элементов последовательности B, начинающихся с того же символа, что и первый элемент пары, либо является пустой строкой
            //(если B не содержит ни одной подходящей строки).Результирующая последовательность называется левым внешним объединением последовательностей A и B по ключу, 
            //определяемому первыми символами исходных строк.Представить найденное объединение в виде последовательности строк вида «EA.EB», 
            //где EA — элемент из A, а EB — либо один из соответствующих ему элементов из B, либо пустая строка. Расположить элементы полученной 
            //строковой последовательности в лексикографическом порядке по возрастанию.
            //Указание.Использовать методы GroupJoin, DefaultIfEmpty, Select и SelectMany.

            //Task("LinqBegin54");
            //GetEnumerableString().GroupJoin(
            //    GetEnumerableString(),
            //    right => right[0],
            //    right => right[0],
            //    (left, e2) => e2.DefaultIfEmpty().Select(right => left +'.'+ right))
            //                    .SelectMany(e => e)
            //                    .OrderBy(e => e)
            //                    .Put();

            //LinqBegin55°. Даны последовательности положительных целых чисел A и B; все числа в каждой последовательности различны. 
            //Найти левое внешнее объединение A и B(см.LinqBegin54), пары в котором должны удовлетворять следующему условию: оба элемента пары 
            //оканчиваются одной и той же цифрой.Представить найденное объединение в виде последовательности строк вида «EA: EB», где EA — число из A,
            //а EB — либо одно из соответствующих ему чисел из B, либо 0(если в B не содержится чисел, соответствующих EA).
            //Расположить элементы полученной последовательности по убыванию чисел EA, а при одинаковых числах EA — по возрастанию чисел EB. 

            //Task("LinqBegin55");
            //GetEnumerableInt().OrderByDescending(e=>e).GroupJoin(
            //                                                     GetEnumerableInt().OrderBy(e=>e),
            //                                                     first => first % 10,
            //                                                     second => second % 10,
            //                                                     (left, e) => e.DefaultIfEmpty().Select(right => left.ToString() + ':' + right.ToString()))
            //                  .SelectMany(e => e)
            //                  .Put();

            //LinqBegin56°. Дана целочисленная последовательность A. Сгруппировать элементы последовательности A, 
            //оканчивающиеся одной и той же цифрой, и на основе этой группировки получить последовательность строк вида «D: S», 
            //где D — ключ группировки(т.е.некоторая цифра, которой оканчивается хотя бы одно из чисел последовательности A), 
            //а S — сумма всех чисел из A, которые оканчиваются цифрой D. Полученную последовательность упорядочить по возрастанию ключей.
            //Указание.Использовать метод GroupBy.

            //Task("LinqBegin56");
            //GetEnumerableInt().GroupBy(
            //                           d => Math.Abs(d % 10),
            //                           s => s,
            //                           (d,s) => string.Format("{0}:{1}", d, s.Sum()))
            //                  .OrderBy(e=>e)
            //                  .Put();

            //LinqBegin57°. Дана целочисленная последовательность.Среди всех элементов последовательности, оканчивающихся одной и той же цифрой, 
            //выбрать максимальный. Полученную последовательность максимальных элементов упорядочить по возрастанию их последних цифр. 

            //Task("LinqBegin57");
            //GetEnumerableInt().GroupBy(
            //                           d => Math.Abs(d % 10), 
            //                           s => s,
            //                           (d,s) => s.Max()).OrderBy(e => Math.Abs(e%10))
            //                  .Put();

            //LinqBegin58°. Дана последовательность непустых строк. Среди всех строк, начинающихся с одного и того же символа, 
            //выбрать наиболее длинную.Если таких строк несколько, то выбрать первую по порядку их следования в исходной последовательности.
            //Полученную последовательность строк упорядочить по возрастанию кодов их начальных символов. 

            //Task("LinqBegin58");
            //GetEnumerableString().GroupBy(c => c[0],
            //                              (a, s) => s.OrderByDescending(e => e.Length).First())
            //                     .OrderBy(c => c[0])
            //                     .Put();

            //LinqBegin59°. Дана последовательность непустых строк, содержащих только заглавные буквы латинского алфавита.
            //Среди всех строк одинаковой длины выбрать первую в лексикографическом порядке(по возрастанию). 
            //Полученную последовательность строк упорядочить по убыванию их длин. 

            //Task("LinqBegin59");
            //GetEnumerableString().GroupBy(c => c.Length,
            //                              (a,s) => s.OrderBy(e => e).First())
            //                     .OrderByDescending(e => e.Length)
            //                     .Put();

            //LinqBegin60°. Дана последовательность непустых строк A, содержащих только заглавные буквы латинского алфавита.
            //Для всех строк, начинающихся с одной и той же буквы, определить их суммарную длину и получить последовательность строк вида «S - C», 
            //где S — суммарная длина всех строк из A, которые начинаются с буквы С. Полученную последовательность упорядочить по убыванию числовых значений сумм, 
            //а при равных значениях сумм — по возрастанию кодов символов C.

            //Task("LinqBegin60");
            //GetEnumerableString().GroupBy(c => c[0],
            //                              (c,s) => new { a = s.Select(e => e.Length).Sum(), c })
            //    .OrderByDescending(e => e.a)
            //    .ThenBy(e => e.c).Select(e => e.a.ToString() + '-'+e.c)
            //    .Put();
            #endregion

        }
    }

}
